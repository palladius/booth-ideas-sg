---
// No server-side logic needed for this component
---

<div class="container mx-auto text-center p-4">
    <h1 class="text-5xl font-bold my-8 bg-clip-text text-transparent bg-gradient-to-r from-red-500 to-orange-500">Pokemon 15 Puzzle</h1>
    <div id="game-board" class="grid grid-cols-4 gap-2 w-96 h-96 mx-auto p-2 bg-gray-800 rounded-lg shadow-lg">
        <!-- Tiles will be generated by script -->
    </div>
    <div class="mt-8 flex justify-center items-center space-x-8">
        <button id="reset-button" class="bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600 text-white font-bold py-3 px-6 rounded-full shadow-md transition-transform transform hover:scale-105">
            Reset
        </button>
        <div class="text-2xl font-mono bg-gray-800 px-4 py-2 rounded-lg shadow-inner">
            <p>Moves: <span id="moves" class="font-bold">0</span></p>
        </div>
        <div class="text-2xl font-mono bg-gray-800 px-4 py-2 rounded-lg shadow-inner">
            <p>Time: <span id="time" class="font-bold">0</span>s</p>
        </div>
    </div>
    <div id="win-message" class="hidden mt-8 text-3xl font-bold text-green-400">
        You Win!
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const gameBoard = document.getElementById('game-board')!;
        const movesSpan = document.getElementById('moves')!;
        const timeSpan = document.getElementById('time')!;
        const resetButton = document.getElementById('reset-button')!;
        const winMessage = document.getElementById('win-message')!;

        let tiles: (number | null)[] = [];
        let moves = 0;
        let timer: number;
        let seconds = 0;
        let emptyTileIndex = 15;

        function initializeGame() {
            moves = 0;
            seconds = 0;
            winMessage.classList.add('hidden');
            clearInterval(timer);
            startTimer();
            updateCounters();
            tiles = Array.from({ length: 15 }, (_, i) => i + 1).concat(null);
            shuffleTiles();
            renderBoard();
        }

        function renderBoard() {
            gameBoard.innerHTML = '';
            tiles.forEach((tile, index) => {
                const tileElement = document.createElement('div');
                tileElement.className = 'h-22 w-22 flex items-center justify-center text-3xl font-bold rounded-lg transition-all duration-300 ease-in-out cursor-pointer shadow-md';
                if (tile) {
                    tileElement.textContent = tile.toString();
                    tileElement.classList.add('bg-gradient-to-r', 'from-red-400', 'to-orange-400', 'hover:from-red-500', 'hover:to-orange-500', 'text-white');
                } else {
                    tileElement.classList.add('bg-gray-700', 'empty');
                }
                tileElement.addEventListener('click', () => handleTileClick(index));
                gameBoard.appendChild(tileElement);
            });
        }

        function handleTileClick(index: number) {
            if (isMoveable(index)) {
                [tiles[emptyTileIndex], tiles[index]] = [tiles[index], tiles[emptyTileIndex]];
                emptyTileIndex = index;
                moves++;
                updateCounters();
                renderBoard();
                if (isWin()) {
                    winMessage.classList.remove('hidden');
                    clearInterval(timer);
                }
            }
        }

        function isMoveable(index: number) {
            const emptyRow = Math.floor(emptyTileIndex / 4);
            const emptyCol = emptyTileIndex % 4;
            const tileRow = Math.floor(index / 4);
            const tileCol = index % 4;

            return (
                (emptyRow === tileRow && Math.abs(emptyCol - tileCol) === 1) ||
                (emptyCol === tileCol && Math.abs(emptyRow - tileRow) === 1)
            );
        }

        function shuffleTiles() {
            // Simple shuffle for now, might not be solvable
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }
            emptyTileIndex = tiles.indexOf(null);
        }

        function isWin() {
            for (let i = 0; i < 15; i++) {
                if (tiles[i] !== i + 1) {
                    return false;
                }
            }
            return true;
        }

        function updateCounters() {
            movesSpan.textContent = moves.toString();
            timeSpan.textContent = seconds.toString() + 's';
        }

        function startTimer() {
            timer = setInterval(() => {
                seconds++;
                updateCounters();
            }, 1000);
        }

        resetButton.addEventListener('click', initializeGame);

        document.addEventListener('keydown', (e) => {
            let targetIndex = -1;
            const emptyRow = Math.floor(emptyTileIndex / 4);
            const emptyCol = emptyTileIndex % 4;

            if (e.key === 'ArrowUp' && emptyRow < 3) {
                targetIndex = emptyTileIndex + 4;
            } else if (e.key === 'ArrowDown' && emptyRow > 0) {
                targetIndex = emptyTileIndex - 4;
            } else if (e.key === 'ArrowLeft' && emptyCol < 3) {
                targetIndex = emptyTileIndex + 1;
            } else if (e.key === 'ArrowRight' && emptyCol > 0) {
                targetIndex = emptyTileIndex - 1;
            }

            if (targetIndex !== -1) {
                handleTileClick(targetIndex);
            }
        });

        initializeGame();
    });
</script>